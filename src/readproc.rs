/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]


use ffi::{pid_t, uid_t, DIR};
use std::os::raw::*;

#[derive(Copy, Clone)]
#[repr(u32)]
#[derive(Debug)]
pub enum ns_type {
    IPCNS = 0,
    MNTNS = 1,
    NETNS = 2,
    PIDNS = 3,
    USERNS = 4,
    UTSNS = 5,
    NUM_NS = 6,
}
#[repr(C)]
#[derive(Copy)]
pub struct proc_t {
    pub tid: c_int,
    pub ppid: c_int,
    pub maj_delta: c_ulong,
    pub min_delta: c_ulong,
    pub pcpu: c_uint,
    pub state: c_char,
    pub pad_1: c_char,
    pub pad_2: c_char,
    pub pad_3: c_char,
    pub utime: c_ulonglong,
    pub stime: c_ulonglong,
    pub cutime: c_ulonglong,
    pub cstime: c_ulonglong,
    pub start_time: c_ulonglong,
    pub signal: [c_char; 18usize],
    pub blocked: [c_char; 18usize],
    pub sigignore: [c_char; 18usize],
    pub sigcatch: [c_char; 18usize],
    pub _sigpnd: [c_char; 18usize],
    pub start_code: c_ulong,
    pub end_code: c_ulong,
    pub start_stack: c_ulong,
    pub kstk_esp: c_ulong,
    pub kstk_eip: c_ulong,
    pub wchan: c_ulong,
    pub priority: c_long,
    pub nice: c_long,
    pub rss: c_long,
    pub alarm: c_long,
    pub size: c_long,
    pub resident: c_long,
    pub share: c_long,
    pub trs: c_long,
    pub lrs: c_long,
    pub drs: c_long,
    pub dt: c_long,
    pub vm_size: c_ulong,
    pub vm_lock: c_ulong,
    pub vm_rss: c_ulong,
    pub vm_data: c_ulong,
    pub vm_stack: c_ulong,
    pub vm_swap: c_ulong,
    pub vm_exe: c_ulong,
    pub vm_lib: c_ulong,
    pub rtprio: c_ulong,
    pub sched: c_ulong,
    pub vsize: c_ulong,
    pub rss_rlim: c_ulong,
    pub flags: c_ulong,
    pub min_flt: c_ulong,
    pub maj_flt: c_ulong,
    pub cmin_flt: c_ulong,
    pub cmaj_flt: c_ulong,
    pub environ: *mut *mut c_char,
    pub cmdline: *mut *mut c_char,
    pub cgroup: *mut *mut c_char,
    pub supgid: *mut c_char,
    pub supgrp: *mut c_char,
    pub euser: [c_char; 33usize],
    pub ruser: [c_char; 33usize],
    pub suser: [c_char; 33usize],
    pub fuser: [c_char; 33usize],
    pub rgroup: [c_char; 33usize],
    pub egroup: [c_char; 33usize],
    pub sgroup: [c_char; 33usize],
    pub fgroup: [c_char; 33usize],
    pub cmd: [c_char; 16usize],
    pub ring: *mut proc_t,
    pub next: *mut proc_t,
    pub pgrp: c_int,
    pub session: c_int,
    pub nlwp: c_int,
    pub tgid: c_int,
    pub tty: c_int,
    pub euid: c_int,
    pub egid: c_int,
    pub ruid: c_int,
    pub rgid: c_int,
    pub suid: c_int,
    pub sgid: c_int,
    pub fuid: c_int,
    pub fgid: c_int,
    pub tpgid: c_int,
    pub exit_signal: c_int,
    pub processor: c_int,
    pub ns: [c_long; 6usize],
}

impl ::std::clone::Clone for proc_t {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for proc_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct PROCTAB {
    pub procfs: *mut DIR,
    pub taskdir: *mut DIR,
    pub taskdir_user: pid_t,
    pub did_fake: c_int,
    pub finder:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut PROCTAB, arg2: *mut proc_t) -> c_int>,
    pub reader: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut PROCTAB, arg2: *mut proc_t) -> *mut proc_t,
    >,
    pub taskfinder: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut PROCTAB,
            arg2: *const proc_t,
            arg3: *mut proc_t,
            arg4: *mut c_char,
        ) -> c_int,
    >,
    pub taskreader: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut PROCTAB,
            arg2: *const proc_t,
            arg3: *mut proc_t,
            arg4: *mut c_char,
        ) -> *mut proc_t,
    >,
    pub pids: *mut pid_t,
    pub uids: *mut uid_t,
    pub nuid: c_int,
    pub i: c_int,
    pub flags: c_uint,
    pub u: c_uint,
    pub vp: *mut c_void,
    pub path: [c_char; 64usize],
    pub pathlen: c_uint,
}
impl ::std::clone::Clone for PROCTAB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::std::default::Default for PROCTAB {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone, Debug)]
pub struct proc_data_t {
    pub tab: *mut *mut proc_t,
    pub proc_: *mut *mut proc_t,
    pub task: *mut *mut proc_t,
    pub n: c_int,
    pub nproc: c_int,
    pub ntask: c_int,
}
impl ::std::default::Default for proc_data_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn get_ns_name(id: c_int) -> *const c_char;
    pub fn get_ns_id(name: *const c_char) -> c_int;
    pub fn openproc(flags: c_int, ...) -> *mut PROCTAB;
    pub fn readproctab2(
        want_proc: ::std::option::Option<unsafe extern "C" fn(buf: *mut proc_t) -> c_int>,
        want_task: ::std::option::Option<unsafe extern "C" fn(buf: *mut proc_t) -> c_int>,
        PT: *mut PROCTAB,
    ) -> *mut proc_data_t;
    pub fn readproctab3(
        want_task: ::std::option::Option<unsafe extern "C" fn(buf: *mut proc_t) -> c_int>,
        PT: *mut PROCTAB,
    ) -> *mut proc_data_t;
    pub fn readproctab(flags: c_int, ...) -> *mut *mut proc_t;
    pub fn closeproc(PT: *mut PROCTAB);
    pub fn readproc(PT: *mut PROCTAB, p: *mut proc_t) -> *mut proc_t;
    pub fn readtask(PT: *mut PROCTAB, p: *const proc_t, t: *mut proc_t) -> *mut proc_t;
    pub fn readeither(PT: *mut PROCTAB, x: *mut proc_t) -> *mut proc_t;
    pub fn read_cmdline(dst: *mut c_char, sz: c_uint, pid: c_uint) -> c_int;
    pub fn look_up_our_self(p: *mut proc_t);
    pub fn freeproc(p: *mut proc_t);
    pub fn get_proc_stats(pid: pid_t, p: *mut proc_t) -> *mut proc_t;
}

// openproc/readproctab:
//
// Return PROCTAB* / *proc_t[] or NULL on error ((probably) "/proc" cannot be
// opened.)  By default readproc will consider all processes as valid to parse
// and return, but not actually fill in the cmdline, environ, and /proc/#/statm
// derived memory fields.
//
// `flags' (a bitwise-or of PROC_* below) modifies the default behavior.  The
// "fill" options will cause more of the proc_t to be filled in.  The "filter"
// options all use the second argument as the pointer to a list of objects:
// process status', process id's, user id's.  The third
// argument is the length of the list (currently only used for lists of user
// id's since uid_t supports no convenient termination sentinel.)

pub static PROC_FILLMEM: c_int = 0x0001; // read statm
pub static PROC_FILLCOM: c_int = 0x0002; // alloc and fill in `cmdline'
pub static PROC_FILLENV: c_int = 0x0004; // alloc and fill in `environ'
pub static PROC_FILLUSR: c_int = 0x0008; // resolve user id number -> user name
pub static PROC_FILLGRP: c_int = 0x0010; // resolve group id number -> group name
pub static PROC_FILLSTATUS: c_int = 0x0020; // read status
pub static PROC_FILLSTAT: c_int = 0x0040; // read stat
pub static PROC_FILLARG: c_int = 0x0100; // alloc and fill in `cmdline'
pub static PROC_FILLCGROUP: c_int = 0x0200; // alloc and fill in `cgroup`
pub static PROC_FILLSUPGRP: c_int = 0x0400; // resolve supplementary group id -> group name
pub static PROC_FILLOOM: c_int = 0x0800; // fill in proc_t oom_score and oom_adj
pub static PROC_FILLNS: c_int = 0x8000; // fill in proc_t namespace information
pub static PROC_FILLSYSTEMD: c_int = 0x80000; // fill in proc_t systemd information
pub static PROC_FILL_LXC: c_int = 0x800000; // fill in proc_t lxcname, if possible

pub static PROC_LOOSE_TASKS: c_int = 0x2000; // treat threads as if they were processes

// consider only processes with one of the passed:
pub static PROC_PID: c_int = 0x1000; // process id numbers ( 0   terminated)
pub static PROC_UID: c_int = 0x4000; // user id numbers    ( length needed )

pub static PROC_EDITCGRPCVT: c_int = 0x10000; // edit `cgroup' as single vector
pub static PROC_EDITCMDLCVT: c_int = 0x20000; // edit `cmdline' as single vector
pub static PROC_EDITENVRCVT: c_int = 0x40000; // edit `environ' as single vector

// it helps to give app code a few spare bits
pub static PROC_SPARE_1: c_int = 0x01000000;
pub static PROC_SPARE_2: c_int = 0x02000000;
pub static PROC_SPARE_3: c_int = 0x04000000;
pub static PROC_SPARE_4: c_int = 0x08000000;
